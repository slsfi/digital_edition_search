input {
    file {
        tags => "historiskarecept"
        path => [ "/var/data/xml/historiskarecept_xml/**/*.xml" ]
        exclude => [ "*_com.xml", "*_int.xml" ] # Exclude comment files and only internally shown files
        start_position => "beginning"
        max_open_files => 4095
        sincedb_path => "/dev/null"
        codec => multiline {
            pattern => "</TEI>"
            negate => true
            what => "next"
            max_lines => 18000
            max_bytes => "40 MiB"
        }
    }
}

filter {
    if "historiskarecept" in [tags] {
        ruby {
            code => 'event["mtime"] = File.mtime(event["path"])'
        }

        fingerprint {
            source => [ "path", 'event["mtime"]']
            target => "[@metadata][fingerprint]"
            method => "MURMUR3"
        }
        
        # Get project_xml_path, xml_type, collection_id, publication_id, type_id and text_language from file path
        grok {
            break_on_match => "false"
            match => {
                "path" => [
                    "/var/data/xml/%{NOTSPACE:project_xml_path}/%{NOTSPACE:xml_type}/",
                    "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER:collection_id}_%{NOTSPACE}",
                    "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER}_%{NUMBER:publication_id}",
                    "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER}_%{NUMBER}_%{NOTSPACE}_%{NUMBER:type_id}.xml",
                    "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER}_%{NOTSPACE}_%{NOTSPACE:text_language}_%{NOTSPACE}.xml"
                ]
            }
        }

        # Get publication_id from file content if not successfully set from file path above
        if ![publication_id] {
            grok {
                match => { 
                    "message" => "<idNo>%{NUMBER:publication_id}</idNo>"
                }
            }
        }

        # Get additional fields from file content
        grok {
            break_on_match => "false"
            match => {
                "message" => [
                    "<placeName type=\"sender\" id=\"%{NUMBER:sender_location_id}\">%{DATA:sender_location_name}</placeName>",
                    "<placeName type=\"adressee\" id=\"%{NUMBER:receiver_location_id}\">%{DATA:receiver_location_name}</placeName>",
                    "<persName type=\"sender\" id=\"%{NUMBER:sender_subject_id}\">%{DATA:sender_subject_name}</persName>",
                    "<persName type=\"adressee\" id=\"%{NUMBER:receiver_subject_id}\">%{DATA:receiver_subject_name}</persName>",
                    "<title type=\"readingtext\" id=\"%{NUMBER:corresp_id}\">%{DATA:corresp_title}</title>",
                    "<origDate>%{NOTSPACE:orig_date}</origDate>"
                ]
            }
        }

        # Remove table of contents from introductions before processing xml
        if "inl" in [xml_type] {
            mutate {
                gsub => [
                    # Remove table of contents div
                    "message", "<div type=\"content\" id=\"content\">(?m:.)*?</div>", ""
                ]
            }
        }

        # Extract fields from xml contents
        xml {
            source => "message"
            store_xml => false
            remove_namespaces => true
            xpath => {
                "string(//teiHeader/fileDesc/titleStmt/title)", "HeadTitle"
                "string(//teiHeader/fileDesc/publicationStmt/publisher)", "publisher"
                "string(//catRef/@target)", "catRef"
                "string(//body)", "textData"
            }
        }
        
        mutate {
            add_field => {
                "TitleIndexed" => "%{HeadTitle}"
                "PublisherIndexed" => "%{publisher}"
                "catRefIndexed" => "%{catRef}"
                "textDataIndexed" => "%{textData}"
            }
        }

        mutate {
            convert => {
                "TitleIndexed" => "string"
                "PublisherIndexed" => "string"
                "catRefIndexed" => "string"
                "textDataIndexed" => "string"
                "collection_id" => "integer"
                "publicaton_id" => "integer"
                "type_id" => "integer"
            }
        }
        
        # Set date for document from properly formed date string
        if [orig_date] =~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
            date {
                match => [ "orig_date", "yyyy-MM-dd" ]
            }
        }

        # Store 
        if [orig_date] !~ /[0-9]{4}-[0-9]{2}-[0-9]{2}$/ {
            grok {
                match => { 
                    "message" => "<origDate>%{NOTSPACE:orig_date_uncertain}</origDate>"
                }
            }
        }

        # Date convert
        if [orig_date] =~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
            # The date string is properly formed -> store it in orig_date_certain
            grok {
                match => { 
                    "message" => "<origDate>%{NOTSPACE:orig_date_certain}</origDate>"
                }
            }

            date {
                match => [ "orig_date_certain", "yyyy-MM-dd" ]
            }
        }

        # Extract year, month and day from properly formed date string
        if [orig_date] =~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
            grok {
                match => { 
                    "message" => "<origDate>%{NOTSPACE:orig_date_year_certain}-%{NOTSPACE:orig_date_month_certain}-%{NOTSPACE:orig_date_day_certain}</origDate>"
                }
            }
        }
   
        grok {
            match => { 
                "message" => "<origDate>%{NOTSPACE:orig_date_year}-%{NOTSPACE:orig_date_month}-%{NOTSPACE:orig_date_day}</origDate>"
            }
        }

        if [orig_date_year] !~ /[0-9]{4}/ {
            grok {
                match => { 
                    "message" => "<origDate>%{NOTSPACE:orig_date_year_uncertain}-%{NOTSPACE}-%{NOTSPACE}</origDate>"
                }
            }
        }

        if [orig_date_month] !~ /[0-9]{2}/ {
            grok {
                match => { 
                    "message" => "<origDate>%{NOTSPACE}-%{NOTSPACE:orig_date_month_uncertain}-%{NOTSPACE}</origDate>"
                }
            }
        }

        if [orig_date_day] !~ /[0-9]{2}/ {
            grok {
                match => { 
                    "message" => "<origDate>%{NOTSPACE}-%{NOTSPACE}-%{NOTSPACE:orig_date_day_uncertain}</origDate>"
                }
            }
        }
        
        if [publication_id] != "" and "_" not in [publication_id] and "tit" not in [xml_type] and "inl" not in [xml_type] and "fore" not in [xml_type] {
            
            # Get publication data from database
            jdbc_streaming {
                jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                jdbc_user => "[DB USER]"
                jdbc_password => "[db user password]"
                jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                jdbc_driver_class => "org.postgresql.Driver"
                statement => "SELECT p.name as pubname, pc.name as colname, p.genre, p.published, pc.published as collection_published
                                FROM publication p 
                                JOIN publication_collection pc ON pc.id = p.publication_collection_id 
                                WHERE p.id = :idparam AND pc.deleted != 1 AND p.deleted != 1 ORDER BY pc.id"
                parameters => { "idparam" => "publication_id" }
                target => "publication_data"
            }

            if "ms" in [xml_type] and [type_id] != "" {
                # Get manuscript data from database
                jdbc_streaming {
                    jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                    jdbc_user => "[DB USER]"
                    jdbc_password => "[db user password]"
                    jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                    jdbc_driver_class => "org.postgresql.Driver"
                    statement => "SELECT ms.name, ms.published
                                    FROM publication_manuscript ms  
                                    WHERE ms.id = :idparam AND ms.deleted != 1 ORDER BY ms.id"
                    parameters => { "idparam" => "type_id" }
                    target => "ms_data"
                }
            }

            if "var" in [xml_type] and [type_id] != "" {
                # Get variant data from database
                jdbc_streaming {
                    jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                    jdbc_user => "[DB USER]"
                    jdbc_password => "[db user password]"
                    jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                    jdbc_driver_class => "org.postgresql.Driver"
                    statement => "SELECT var.name, var.published
                                    FROM publication_version var  
                                    WHERE var.id = :idparam AND var.deleted != 1 ORDER BY var.id"
                    parameters => { "idparam" => "type_id" }
                    target => "var_data"
                }
            }
            
        } else if [collection_id] != "" {
            # Get collection data from database
            jdbc_streaming {
                jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                jdbc_user => "[DB USER]"
                jdbc_password => "[db user password]"
                jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                jdbc_driver_class => "org.postgresql.Driver"
                statement => "SELECT pc.name as colname, pc.published as collection_published
                                FROM publication_collection pc 
                                WHERE pc.id = :idparam AND pc.deleted != 1 ORDER BY pc.id"
                parameters => { "idparam" => "collection_id" }
                target => "publication_data"
            }
        }

        if [message] {
            mutate {
                remove_field => [ "message", "HeadTitle", "publisher", "catRef", "textData" ]
            }
        }
    }
}

output {
    if "historiskarecept" in [tags]{
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "historiskarecept"
            document_id => "%{[@metadata][fingerprint]}"
        }
    }
}
