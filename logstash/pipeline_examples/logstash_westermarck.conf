input {
    file {
        tags => "westermarck"
        path => [ "/var/data/xml/westermarck_xml/**/*.xml" ]
        exclude => [ "*_com.xml", "*_int.xml" ] # Exclude comment files and only internally shown files
        start_position => "beginning"
        max_open_files => 4095
        close_older => "5 min"
        sincedb_path => "/dev/null"
        codec => multiline {
            pattern => "^<\?xml .*?\?>"
            negate => true
            what => "previous"
            max_lines => 18000
            max_bytes => "40 MiB"
            auto_flush_interval => 3
        }
    }
}

filter {
    if "westermarck" in [tags] {
        fingerprint {
            source => "path"
            target => "[@metadata][fingerprint]"
            method => "MD5"
            key => "westermarck"
            base64encode => true
        }
        
        # Get project_xml_path, text_type, collection_id, publication_id, type_id and language from file path
        grok {
            match => {
                "path" => "/var/data/xml/%{NOTSPACE:project_xml_path}/%{NOTSPACE:text_type}/"
            }
        }

        grok {
            match => {
                "path" => "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER:collection_id}_%{NOTSPACE}"
            }
        }

        grok {
            match => {
                "path" => "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER}_%{NUMBER:publication_id}_"
            }
        }

        grok {
            match => {
                "path" => "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER}_%{NUMBER}_%{NOTSPACE}_%{NUMBER:type_id}.xml"
            }
        }

        grok {
            match => {
                "path" => "/var/data/xml/%{NOTSPACE}/%{NOTSPACE}/%{NUMBER}_%{NOTSPACE}_%{NOTSPACE:language}_(?<publishedVersion>[a-zA-Z]{1,}).xml"
            }
        }


        # Get publication_id from file content if not successfully set from file path above
        if [text_type] != "tit" and [text_type] != "fore" and [text_type] != "inl" and [publication_id] !~ /[0-9]{1,}/ {
            grok {
                match => { 
                    "message" => "<slsEdData:publicationId>%{NUMBER:publication_id}</slsEdData:publicationId>"
                }
            }
        }

        # Format content before processing as xml
        # Note: (?s) at the start of the find pattern makes . match newlines
        mutate {
            gsub => [
                # Remove attributes except for TEI namespace declaration from TEI root element
                "message", '<TEI\s+[^>]+>', '<TEI xmlns="http://www.tei-c.org/ns/1.0">',
                # Remove xml:space preserve attribute
                "message", ' xml:space="preserve"', '',
                # Remove space before self-closing tag end
                "message", " />", "/>",
                # Remove tab-characters
                "message", "\t", "",
                 # Insert space before notes
                "message", "<note ", " <note ",
                # Remove formula tags
                "message", "(?s)<formula.+?</formula>", "",
                # Remove orig tags
                "message", "(?s)<choice><orig>.+?</orig>", "<choice>",
                # Remove expan tags
                "message", "(?s)</abbr><expan.+?</expan>", "</abbr>",
                # Add space before line break tags (since they can be inline)
                "message", "<lb/>", " <lb/>",
                # Remove multiple, consecutive spaces
                "message", "[ ]{2,}", " ",
                # Remove carriage returns
                "message", "\r", "",
                # Remove soft hyphen characters
                "message", "&#173;", ""
            ]
        }

        if [text_type] != "var" {
            mutate {
                gsub => [
                    # Remove rdg tags
                    "message", "(?s)<rdg>.+?</rdg>", ""
                ]
            }
        }

        # Format introduction content before processing as xml
        if [text_type] == "inl" {
            mutate {
                gsub => [
                    # Remove table of contents div
                    "message", '<div type="content" id="content">(?m:.)*?</div>', ''
                ]
            }
        }

        # Format established text content before processing as xml
        if [text_type] == "est" {
            mutate {
                gsub => [
                    # Remove option one in alternative phrases
                    "message", '(?s)<seg type="alt">.+?<add type="choice"', '<seg type="alt"><add type="choice"',
                    # Add space between del and add tags
                    "message", "</del><add", "</del> <add",
                    # Add space before alternative phrase
                    "message", '<add type="choice">', ' <add type="choice">'
                ]
            }
        }

        # Format manuscript text content before processing as xml
        if [text_type] == "ms" {
            mutate {
                gsub => [
                    # Add space between del and add tags
                    "message", "</del><add", "</del> <add",
                    # Add space before alternative phrase
                    "message", '<add type="choice">', ' <add type="choice">'
                ]
            }
        }

        # Extract fields from xml contents
        xml {
            source => "message"
            store_xml => false
            remove_namespaces => true
            xpath => {
                "string(//teiHeader/fileDesc/titleStmt/title[not(@type)])" => "doc_title"
                "string(//teiHeader/fileDesc/sourceDesc//origDate[1]/@when)" => "xmlOrigDate"
                "string(//teiHeader/fileDesc/sourceDesc//date[1]/@when)" => "xmlOrigDate2"
                "string(//teiHeader/profileDesc/correspDesc/correspAction[@type='sent']/date[1]/@when)" => "xmlSentDate"
                "string(//teiHeader/profileDesc/correspDesc/correspAction[@type='received']/date[1]/@when)" => "xmlReceivedDate"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='sent']/persName" => "sender_subject_name"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='sent']/persName/@key" => "sender_subject_id"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='sent']/placeName" => "sender_location_name"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='sent']/placeName/@key" => "sender_location_id"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='received']/persName" => "receiver_subject_name"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='received']/persName/@key" => "receiver_subject_id"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='received']/placeName" => "receiver_location_name"
                "//teiHeader/profileDesc/correspDesc/correspAction[@type='received']/placeName/@key" => "receiver_location_id"
                "string(//text)" => "text_data"
                "string(//text/@xml:lang | //text/@lang)" => "text_language"
            }
        }

        # Choose orig_date with fallbacks
        if [xmlOrigDate] and [xmlOrigDate] != "" {
            mutate {
                add_field => {
                    "orig_date" => "%{xmlOrigDate}"
                }
            }
        } else if [xmlOrigDate2] and [xmlOrigDate2] != "" {
            mutate {
                add_field => {
                    "orig_date" => "%{xmlOrigDate2}"
                }
            }
        } else if [xmlSentDate] and [xmlSentDate] != "" {
            mutate {
                add_field => {
                    "orig_date" => "%{xmlSentDate}"
                }
            }
        } else if [xmlReceivedDate] and [xmlReceivedDate] != "" {
            mutate {
                add_field => {
                    "orig_date" => "%{xmlReceivedDate}"
                }
            }
        }

        mutate {
            convert => {
                "doc_title" => "string"
                "text_data" => "string"
                "orig_date" => "string"
                "sender_subject_name" => "string"
                "sender_location_name" => "string"
                "sender_subject_id" => "string"
                "sender_location_id" => "string"
                "receiver_subject_name" => "string"
                "receiver_location_name" => "string"
                "receiver_subject_id" => "string"
                "receiver_location_id" => "string"
            }
        }

        # Process text_data
        if [text_data] {
            mutate {
                gsub => [
                    # Remove narrow non-breaking spaces
                    "text_data", " ", "",
                    # Replace non-breaking spaces with normal spaces
                    "text_data", " ", " "
                ]
            }
        }

        # Date handling
        if [orig_date] =~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/ {
            # The date string is properly formed -> 
            # Store the proper date in orig_date_certain
            mutate {
                add_field => {
                    "orig_date_certain" => "%{orig_date}"
                }
            }

            # Extract year, month and day from properly formed date string
            # If it doesn't match, grok does nothing and no fields are created
            grok {
                match => {
                    "orig_date" => "^%{YEAR:orig_date_year_certain}-%{MONTHNUM:orig_date_month_certain}-%{MONTHDAY:orig_date_day_certain}$"
                }
            }

            mutate {
                add_field => {
                    "orig_date_year" => "%{orig_date_year_certain}"
                }
            }
        } else {
            # Try to get some year, month and day data from orig_date - one of the following should match
            # Year, month and day in x-x-x format
            grok {
                match => { 
                    "orig_date" => "^%{NOTSPACE:orig_date_year}-%{NOTSPACE:orig_date_month}-%{NOTSPACE:orig_date_day}$"
                }
            }
            # Year and month in yyyy-mm format
            grok {
                match => { 
                    "orig_date" => "^%{YEAR:orig_date_year}-%{MONTHNUM:orig_date_month}$"
                }
            }
            # Month and day in --mm-dd format
            grok {
                match => { 
                    "orig_date" => "^--%{MONTHNUM:orig_date_month}-%{MONTHDAY:orig_date_day}$"
                }
            }
            # Month in --mm format
            grok {
                match => { 
                    "orig_date" => "^--%{MONTHNUM:orig_date_month}$"
                }
            }
            # Day in ---dd format
            grok {
                match => { 
                    "orig_date" => "^---%{MONTHDAY:orig_date_day}$"
                }
            }
            if ![orig_date_year] and ![orig_date_month] and ![orig_date_day] {
                # Year in yyyy format
                grok {
                    match => { 
                        "orig_date" => "^%{YEAR:orig_date_year}$"
                    }
                }

                if ![orig_date_year] {
                    # Year in some partial yyXX format
                    grok {
                        match => { 
                            "orig_date" => "^%{NOTSPACE:orig_date_year}$"
                        }
                    }
                }
            }
        }

        # Form date field for sorting, must be a proper date
        if [orig_date_certain] and [orig_date_certain] != "" {
            mutate {
                add_field => {
                    "orig_date_sort" => "%{orig_date_certain}"
                }
            }
        } else if [orig_date_year] =~ /^[0-9]{4}$/ and [orig_date_month] =~ /^[0-9]{2}$/ and ![orig_date_day] {
            if [orig_date_month] == "02" {
                mutate {
                    add_field => {
                        "orig_date_sort" => "%{orig_date_year}-%{orig_date_month}-28"
                    }
                }
            } else if [orig_date_month] == "04" or [orig_date_month] == "06" or [orig_date_month] == "09" or [orig_date_month] == "11" {
                mutate {
                    add_field => {
                        "orig_date_sort" => "%{orig_date_year}-%{orig_date_month}-30"
                    }
                }
            } else {
                mutate {
                    add_field => {
                        "orig_date_sort" => "%{orig_date_year}-%{orig_date_month}-31"
                    }
                }
            }
        } else if [orig_date_year] =~ /^[0-9]{4}$/ {
            mutate {
                add_field => {
                    "orig_date_sort" => "%{orig_date_year}-12-31"
                }
            }
        }

        if ([text_type] == "tit" or [text_type] == "inl" or [text_type] == "fore") and [collection_id] =~ /[0-9]{1,}/ {
            # Get collection data from database
            jdbc_streaming {
                jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                jdbc_user => "[DB USER]"
                jdbc_password => "[db user password]"
                jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                jdbc_driver_class => "org.postgresql.Driver"
                statement => "SELECT pc.name as collection_name, pc.published as collection_published, pc.deleted as collection_deleted
                                FROM publication_collection pc 
                                WHERE pc.id = :idparam ORDER BY pc.id"
                parameters => { "idparam" => "collection_id" }
                target => "publication_data"
            }
        } else if [publication_id] =~ /[0-9]{1,}/ {
            # Get publication data from database
            jdbc_streaming {
                jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                jdbc_user => "[DB USER]"
                jdbc_password => "[db user password]"
                jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                jdbc_driver_class => "org.postgresql.Driver"
                statement => "SELECT p.name as publication_name, pc.name as collection_name, p.genre, p.published, p.deleted, p.language, pc.published as collection_published, pc.deleted as collection_deleted
                                FROM publication p 
                                JOIN publication_collection pc ON pc.id = p.publication_collection_id 
                                WHERE p.id = :idparam ORDER BY pc.id"
                parameters => { "idparam" => "publication_id" }
                target => "publication_data"
            }

            if [text_type] == "ms" and [type_id] =~ /[0-9]{1,}/ {
                # Get manuscript data from database
                jdbc_streaming {
                    jdbc_connection_string => "jdbc:postgresql://[IP OF DATABASE]:5432/digitaledition"
                    jdbc_user => "[DB USER]"
                    jdbc_password => "[db user password]"
                    jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
                    jdbc_driver_class => "org.postgresql.Driver"
                    statement => "SELECT ms.name, ms.published, ms.deleted, ms.language
                                    FROM publication_manuscript ms  
                                    WHERE ms.id = :idparam ORDER BY ms.id"
                    parameters => { "idparam" => "type_id" }
                    target => "ms_data"
                }
            }
        }

        # Add a field for determining if the text has been deleted
        mutate {
            add_field => { "deleted" => 0 }
        }

        if [publication_data][0][collection_deleted] == 1 {
            mutate {
                update => { "deleted" => 1 }
            }
        } else if [publication_id] =~ /[0-9]{1,}/ and [publication_data][0][deleted] == 1 {
            mutate {
                update => { "deleted" => 1 }
            }
        } else if [type_id] =~ /[0-9]{1,}/ and [text_type] == "ms" and [ms_data][0][deleted] == 1 {
            mutate {
                update => { "deleted" => 1 }
            }
        }

        # Add a field for the text's published status
        mutate {
            add_field => { "published" => 2 }
        }
        if [publication_data][0][collection_published] == 1 {
            mutate {
                update => { "published" => 1 }
            }
        } else if [publication_data][0][collection_published] == 0 {
            mutate {
                update => { "published" => 0 }
            }
        } else if [publication_id] =~ /[0-9]{1,}/ and [publication_data][0][published] == 1 {
            mutate {
                update => { "published" => 1 }
            }
        } else if [publication_id] =~ /[0-9]{1,}/ and [publication_data][0][published] == 0 {
            mutate {
                update => { "published" => 0 }
            }
        }

        # Add a field with the primary text title
        if ([text_type] == "tit" or [text_type] == "inl" or [text_type] == "fore") {
            mutate {
                add_field => { "text_title" => "%{doc_title}" }
            }
        } else {
            if [text_type] == "ms" and [type_id] =~ /[0-9]{1,}/ {
                mutate {
                    add_field => { "text_title" => "%{[ms_data][0][name]}" }
                }
            } else {
                mutate {
                    add_field => { "text_title" => "%{[publication_data][0][publication_name]}" }
                }
            }
        }

        # If the text language field is not set from XML, set it from
        # database data
        if ![text_language] {
            if [text_type] == "ms" and [type_id] =~ /[0-9]{1,}/ {
                mutate {
                    add_field => { "text_language" => "%{[ms_data][0][language]}"}
                }
            } else {
                mutate {
                    add_field => { "text_language" => "%{[publication_data][0][language]}"}
                }
            }
        }

        mutate {
            strip => [ "doc_title", "text_title", "text_data" ]
        }

        # Add a field with a copy of document_id which can be used as a tie breaker for the sort when using search_after for pagination in elastic
        mutate {
            add_field => { "tie_breaker_id" => "%{[@metadata][fingerprint]}" }
        }

        # Clean up fields not wanted in the index
        if [message] {
            mutate {
                remove_field => [
                    "message",
                    "xmlOrigDate",
                    "xmlOrigDate2",
                    "xmlSentDate",
                    "xmlReceivedDate",
                    "orig_date_year_certain",
                    "orig_date_month_certain",
                    "orig_date_day_certain",
                    "orig_date_month",
                    "orig_date_day"
                ]
            }
        }
        if [publishedVersion] {
            mutate {
                remove_field => [ "publishedVersion" ]
            }
        }
    }
}

output {
    if "westermarck" in [tags] {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "westermarck"
            document_id => "%{[@metadata][fingerprint]}"
        }
    }
}
